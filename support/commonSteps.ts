import { Given, When, Then } from '@cucumber/cucumber';
import type { ICustomWorld } from './world';
import { PageFactory, IBasePage } from './pageFactory';

/**
 * COMMON STEPS - Universal step definitions that work with any feature.
 * 
 * This file is STATIC and should NOT be regenerated by AI.
 * It uses the PageFactory to dynamically load the correct Page Object
 * based on the current feature being executed.
 * 
 * When new features are added via AI upload, they will automatically work
 * as the PageFactory discovers them based on naming conventions.
 * 
 * CRITICAL: Page object instances are stored in the World context (per-scenario)
 * NOT in global variables, to prevent race conditions in parallel execution.
 */

/**
 * Gets or creates the Page Object for the current feature.
 * Uses the feature name from the world context to determine which Page Object to load.
 * CRITICAL: Stores page instance in world.pageInstance to avoid race conditions.
 */
async function getPageForCurrentFeature(world: ICustomWorld): Promise<IBasePage> {
    // Get current feature name from world context (set in hooks.ts)
    const featureName = (world as any).currentFeatureName || '';

    // Check if we already have a page instance for this scenario
    if ((world as any).pageInstance) {
        return (world as any).pageInstance;
    }

    // Create new page instance for this scenario
    const pageInstance = await PageFactory.getPage(featureName, world.page!);
    (world as any).pageInstance = pageInstance;
    console.log(`[CommonSteps] Using Page Object for feature: ${featureName}`);

    return pageInstance;
}

// ============================================================================
// NAVIGATION STEPS
// ============================================================================

Given('I am on the {string} page', async function (this: ICustomWorld, pageName: string) {
    const page = await getPageForCurrentFeature(this);
    const config = await page.getEnvironmentConfig();

    let url: string;
    switch (pageName) {
        case 'login':
            url = config.baseLoginUrl;
            break;
        default:
            if (pageName.startsWith('http://') || pageName.startsWith('https://')) {
                url = pageName;
            } else {
                throw new Error(`Unknown page: ${pageName}. Use "login" for login page or provide full URL.`);
            }
    }

    await page.navigateToUrl(url);
});

// ============================================================================
// INPUT STEPS
// ============================================================================

When('I enter {string} into the {string} field', async function (this: ICustomWorld, value: string, fieldName: string) {
    const page = await getPageForCurrentFeature(this);
    await page.fillField(fieldName, value);
});

// ============================================================================
// CLICK STEPS
// ============================================================================

When('I click {string}', async function (this: ICustomWorld, elementName: string) {
    const page = await getPageForCurrentFeature(this);
    await page.clickElement(elementName);
});

// ============================================================================
// VERIFICATION STEPS
// ============================================================================

Then('I should see the text {string} in the {string} element', async function (this: ICustomWorld, expectedText: string, selector: string) {
    const page = await getPageForCurrentFeature(this);
    // Check if page has verifyTextInElement method
    if ('verifyTextInElement' in page) {
        await (page as any).verifyTextInElement(selector, expectedText);
    } else {
        throw new Error(`Page Object does not support text verification. Selector: ${selector}`);
    }
});

// ============================================================================
// OPTIONAL: Additional common steps can be added here
// ============================================================================

// Reset page cache when scenario ends (handled automatically via world.pageInstance per-scenario)
// This function is kept for backward compatibility but now only clears PageFactory module cache
export function resetPageCache(): void {
    // Note: Per-scenario page instances are cleaned up automatically when scenario ends
    // Only the module cache (for require()) needs clearing if needed
    PageFactory.clearCache();
}
